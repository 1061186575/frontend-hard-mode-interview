# 陆.3.2 JavaScript的函数式编程探索

[上一篇](6.3.1.md)讲了函数式编程的理论知识，本篇探索一下JavaScript如何进行函数式编程。

## Ramda，一款实用的 JavaScript 函数式编程库

[Ramda](https://ramda.cn/)是一个非常适合函数式编程的函数库。函数库类似的有[lodash](https://www.lodashjs.com/)。

lodash已经很成熟了，提供了足够好用的函数，那为什么还要Ramda呢？笔者认为：Ramda的理念更适合函数式编程。

Ramda的理念是：

> Function first,data last.

也即函数优先，数据靠后。体现在具体的用法区别上，就是lodash会把第一个参数当成要处理的数据，函数等放在第一个参数之后传进来。而Ramda会把要出来的数据放在最后一个参数，最后一个参数之前的参数，都是传入的函数。

```javascript
const xs = [{a: 1}, {a: 2}, {a: 3}];

//lodash：数据在前
_.findIndex(xs, (o)=> o.a== 2); //>> 0


//Ramda：数据在最末尾
R.findIndex(R.propEq('a', 2),xs); //>> 1
```

### 将数据放在后面有什么好处呢？

好处是写的代码更精简，更方便阅读理解。这点结合Ramda的柯里化会感受更加明显。

## Ramda的函数都是柯里化的

上面的代码第8行，可以写成：

```javascript
R.findIndex(R.propEq('a', 2))(xs); //>> 1
```

也是可以的，这不就是柯里化形态吗。没错，而Ramda提供的所有函数都是已经柯里化的，这可以从源代码找到证据。看看最简单的[add函数](https://github.com/ramda/ramda/blob/master/source/add.js)的源代码：

```javascript
import _curry2 from './internal/_curry2';


/**
 * Adds two values.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} a
 * @param {Number} b
 * @return {Number}
 * @see R.subtract
 * @example
 *
 *      R.add(2, 3);       //=>  5
 *      R.add(7)(10);      //=> 17
 */
var add = _curry2(function add(a, b) {
  return Number(a) + Number(b);
});
export default add;
```

上面代码第1行就引入了`_curry2`这个内部函数，然后第21行调用`_curry2`将`add`函数柯里化。类似的每个函数，都这样处理过。因此Ramda对外提供的每个函数都是柯里化过的。

### 这样的目的是什么呢？

仍然是为了配合本文开头讲述的“将数据放在末尾”，以便体现代码的简洁性，可读性。现在举例说明。

```javascript
//todo
```

//todo



## 参考文献

{% hint style="info" %}
[Ramda 的哲学](https://zhuanlan.zhihu.com/p/32207359)
{% endhint %}

