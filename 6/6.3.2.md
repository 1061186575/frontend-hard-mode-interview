# 陆.3.2 JavaScript的函数式编程探索

[上一篇](6.3.1.md)讲了函数式编程的理论知识，本篇探索一下JavaScript如何进行函数式编程。

## Ramda，一款实用的 JavaScript 函数式编程库

工欲善其事必先利其器，JavaScript函数式编程怎能没有库这种利器！

[Ramda](https://ramda.cn/)是一个非常适合函数式编程的函数库。函数库类似的有[lodash](https://www.lodashjs.com/)。

lodash已经很成熟了，提供了足够好用的函数，那为什么还要Ramda呢？笔者认为：Ramda的理念更适合函数式编程。

Ramda的理念是：

> Function first,data last.

也即函数优先，数据靠后。体现在具体的用法区别上，就是lodash会把第一个参数当成要处理的数据，函数等放在第一个参数之后传进来。而Ramda会把要出来的数据放在最后一个参数，最后一个参数之前的参数，都是传入的函数。

```javascript
const list = [{a: 1}, {a: 2}, {a: 3}];

//lodash：数据在前
_.findIndex(list, (o)=> o.a== 2); //>> 0


//Ramda：数据在最末尾
R.findIndex(R.propEq('a', 2),list); //>> 1
```

### 将数据放在后面有什么好处呢？

好处是写的代码更精简，更方便阅读理解。这点结合Ramda的柯里化会感受更加明显。

## Ramda的函数都是柯里化的

上面的代码第8行，可以写成：

```javascript
R.findIndex(R.propEq('a', 2))(xs); //>> 1
```

也是可以的，这不就是柯里化形态吗。没错，而Ramda提供的所有函数都是已经柯里化的，这可以从源代码找到证据。看看最简单的[add函数](https://github.com/ramda/ramda/blob/master/source/add.js)的源代码：

```javascript
import _curry2 from './internal/_curry2';


/**
 * Adds two values.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} a
 * @param {Number} b
 * @return {Number}
 * @see R.subtract
 * @example
 *
 *      R.add(2, 3);       //=>  5
 *      R.add(7)(10);      //=> 17
 */
var add = _curry2(function add(a, b) {
  return Number(a) + Number(b);
});
export default add;
```

上面代码第1行就引入了`_curry2`这个内部函数，然后第21行调用`_curry2`将`add`函数柯里化。Ramda每个对外的函数，都这样处理过。因此Ramda对外提供的每个函数都是柯里化过的。

### 全部柯里化的目的是什么呢？

仍然是为了与前面讲述的“将数据放在末尾”结合使用，以便体现代码的简洁、可读性。

现在举例说明：求列表中a的值大于1的项，然后取各项值之和。

```javascript
const list = [{ a: 1 }, { a: 2 }, { a: 3 }];

//lodash
{
    let sum = function (data) {    //根据给定的列表求和
        return _.reduce(data, (a, b) => a + b.a,0);
    }
    let getList = function (data) {    //得到值>1的项组成的列表
        return _.filter(data, (o) => o.a > 1);
    }
    let total = _.flow(getList, sum)(list);
    console.log(total);//>> 5
}


//Ramda
{
    let sum = R.reduce((a,b)=>a+b.a,0);//正因为Ramda是柯里化过的，才可将参数拆开、将函数型
    let getList = R.filter((o) => o.a > 1);//的参数放在这里的函数里，且将剩余的data参数略掉
    let total = R.compose(sum,getList)(list);//最后再统一传参
    console.log(total);//>> 5
}
```

第18、19行，需要传递的参数`data`不见了！居然可以没`data`什么事？！这就引出了一种无参数的编程风格：**Pointfree**，放在[下一篇](6.3.3.md)单独介绍。

可以发现正是因为Ramda把数据放在参数的最后一个位置，同时每个函数都柯里化过，因此能够省略一些参数，代码才变得更简洁，更易读。



## 参考文献

{% hint style="info" %}
[Ramda 的哲学](https://zhuanlan.zhihu.com/p/32207359)
{% endhint %}

