# 陆.1.6 依赖倒置原则

## 01.以一个渣男练成的例子开篇吧

小明今年20岁上大二，喜欢漂亮女孩，经过长达半年的马拉松式追求，终于俘获了聪明美丽的女孩小羽儿的芳心。两人天天腻歪在一起，一起上自习、吃饭、看电影、甚至kiss……更多的内容少儿不宜。总之，有个女朋友的感觉太好啦，小明已经彻底离不开小羽儿。代码实现如下：

```javascript
/**
 * 小羽儿
 */
class XiaoYuEr {
   constructor() {
      this.name = "小羽儿";
   }
}

/**
 * 小明
 */
class XiaoMing {
   girlfriend = new XiaoYuEr();
   constructor() {
      this.name = "小明";
   }

   study() {
      console.log(`${this.name}和${this.girlfriend.name}在上自习`);
   }
   eat() {
      console.log(`${this.name}和${this.girlfriend.name}在吃饭`);
   }
   watchMovie() {
      console.log(`${this.name}和${this.girlfriend.name}在看电影`);
   }
   kiss() {
      console.log(`${this.name}和${this.girlfriend.name}在接吻`);
   }
}

let xiaoming = new XiaoMing();
xiaoming.study(); //>>小明和小羽儿在上自习
xiaoming.eat(); //>>小明和小羽儿在吃饭
xiaoming.watchMovie(); //>>小明和小羽儿在看电影
xiaoming.kiss(); //>>小明和小羽儿在接吻
```

幸福的日子持续了一年，小羽儿的父母想送她去美国留学，小明万般不舍，但是无奈贫贱不能移，只能看着女朋友离自己而去。伤心了几个月，好在小明长得酷酷的又有才气，很快有个漂亮的女孩小萌的喜欢上了他。于是……

```javascript
/**
 * 小萌
 */
class XiaoMeng {
   constructor() {
      this.name = "小萌";
   }
}

/**
 * 小明
 */
class XiaoMing {
   girlfriend = new XiaoMeng(); //因为换了女朋友，小明要在心里把女友换成了小萌，
                                //里外都要换，代价是昂贵的
   constructor() {
      this.name = "小明";
   }

   study() {
      console.log(`${this.name}和${this.girlfriend.name}在上自习`);
   }
   eat() {
      console.log(`${this.name}和${this.girlfriend.name}在吃饭`);
   }
   watchMovie() {
      console.log(`${this.name}和${this.girlfriend.name}在看电影`);
   }
   kiss() {
      console.log(`${this.name}和${this.girlfriend.name}在接吻`);
   }
}

let xiaoming = new XiaoMing();
xiaoming.study(); //>>小明和小萌在上自习
xiaoming.eat(); //>>小明和小萌在吃饭
xiaoming.watchMovie(); //>>小明和小萌在看电影
xiaoming.kiss(); //>>小明和小萌在接吻
```

有了新女友，小明很快走出了郁郁寡欢的日子。梅开二度看似美好，但其实小明没有那么爱小萌，这段恋情很快就结束了。然后某天，小明突然明白了，原来自己只是害怕孤独，需要有个大学女生陪伴而已。于是代码如下……

```javascript
/**
 * 大学女生
 */
class CollegeGirl {
   constructor() {
      this.name = "大学女生";
   }
}

class Girl1 extends CollegeGirl {
   constructor() {
      super();
      this.name = "小花";
   }
}
class Girl2 extends CollegeGirl {
   constructor() {
      super();
      this.name = "小蓝";
   }
}
class Girl3 extends CollegeGirl {
   constructor() {
      super();
      this.name = "小红";
   }
}
class Girl4 extends CollegeGirl {
   constructor() {
      super();
      this.name = "小美";
   }
}
class Girl5 extends CollegeGirl {
   constructor() {
      super();
      this.name = "小丫";
   }
}
class Girl6 extends CollegeGirl {
   constructor() {
      super();
      this.name = "小晴";
   }
}
class Girl7 extends CollegeGirl {
   constructor() {
      super();
      this.name = "小珂";
   }
}

/**
 * 小明
 */
class XiaoMing {
   constructor(collegeGirl) {
      this.name = "小明";
      this.girlfriend = collegeGirl;
   }

   study() {
      console.log(`${this.name}和${this.girlfriend.name}在上自习`);
   }
   eat() {
      console.log(`${this.name}和${this.girlfriend.name}在吃饭`);
   }
   watchMovie() {
      console.log(`${this.name}和${this.girlfriend.name}在看电影`);
   }
   kiss() {
      console.log(`${this.name}和${this.girlfriend.name}在接吻`);
   }
}

/**
 * 小明祈祷老天，老天感其诚，每天都安排不同女孩给他
 */
function showMeCollegeGirl() {
   let now = new Date().getUTCDay() % 7;
   switch (now) {
      case 1:
         return new Girl1();
      case 2:
         return new Girl2();
      case 3:
         return new Girl3();
      case 4:
         return new Girl4();
      case 5:
         return new Girl5();
      case 6:
         return new Girl6();
      case 0:
         return new Girl7();
   }

}

let xiaoming = new XiaoMing(showMeCollegeGirl());//将依赖的对象注入构造函数
//小明每天和不同女孩一起，过起了没羞没臊的渣男生活
xiaoming.study(); 
xiaoming.eat(); 
xiaoming.watchMovie(); 
xiaoming.kiss(); 
```

上面这段代码，显示了小明**从依赖具体**的女孩小玉儿，**转为依赖抽象**的大学女生。这样之后，小明内心不用更换了女朋友的位置，因此没有心理包袱，感觉很轻松。然后第107行在构造函数里传递（注入）了具体的大学女生，这就叫做**依赖注入。**

上面这个例子比较丧 🤣 ，但是又的确是大多数男孩的成长历程，真实得可怕。我们要相信等小明再成熟一点儿，知道自己需要什么样的女孩陪伴终身之后，就会变成暖男的 😇 。

好了，我们继续接着来讲依赖倒置。

## 02.依赖倒置

> 依赖倒置原则（Dependence Inversion Principle）是程序要依赖于抽象，不要依赖于具体实现。简单的说就是要求针对抽象进行编程，不要对具体实现进行编程，这样就降低了与具体实现模块的耦合。

> 1. 高层次模块不应该依赖低层次模块，它们都应该依赖于抽象。
> 2. 抽象不应该依赖于具体，具体应该依赖于抽象。

```text

```

## 03.何谓高层次，何谓低层次？

## 04.何谓抽象？

## 05.代码示例

## 参考文献

{% hint style="info" %}
[Dependency inversion principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)  
[DIP: The Dependency-Inversion Principle](https://medium.com/@gabriellamedas/dip-the-dependency-inversion-principle-dbe0f784f3aa)
{% endhint %}

