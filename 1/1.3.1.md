# 壹.3.1 深拷贝与浅拷贝

//todo

## 壹.3.1.1 深拷贝

示例代码如下：

```javascript
function deepCopy(obj) {
    // 创建一个新对象
    let result = {}
    let keys = Object.keys(obj),
        key = null,
        temp = null;

    for (let i = 0; i < keys.length; i++) {
        key = keys[i];    
        temp = obj[key];
        // 如果字段的值也是一个对象则递归操作
        if (temp && typeof temp === 'object') {
            result[key] = deepCopy(temp);
        } else {
        // 否则直接赋值给新对象
            result[key] = temp;
        }
    }
    return result;
}
```

## 壹.3.1.2 循环引用之深拷贝

例如这种情况，obj引用自身：

```javascript
var obj = {
    name: 'coffe1891',
    sex: 'male'
};
obj['deefRef'] = obj;
```

此时如果调用上面的deepCopy函数的话，会陷入一个死循环，从而导致堆栈溢出。解决这个问题也非常简单，只需要判断一个对象的字段是否引用了这个对象或这个对象的任意父级即可，修改一下代码：

```javascript
function deepCopy(obj, parent = null) {
    // 创建一个新对象
    let result = {};
    let keys = Object.keys(obj),
        key = null,
        temp = null,
        _parent = parent;
    // 该字段有父级则需要追溯该字段的父级
    while (_parent) {
        // 如果该字段引用了它的父级则为循环引用
        if (_parent.originalParent === obj) {
            // 循环引用直接返回同级的新对象
            return _parent.currentParent;
        }
        _parent = _parent.parent;
    }
    for (let i = 0; i < keys.length; i++) {
        key = keys[i];
        temp = obj[key];
        // 如果字段的值也是一个对象
        if (temp && typeof temp === 'object') {
            // 递归执行深拷贝 将同级的待拷贝对象与新对象传递给 parent 方便追溯循环引用
            result[key] = DeepCopy(temp, {
                originalParent: obj,
                currentParent: result,
                parent: parent
            });

        } else {
            result[key] = temp;
        }
    }
    return result;
}
```

## 壹.3.1.3 非循环引用的子对象之拷贝

上面已经解决了深拷贝循环引用的问题，但是还不是特别的完善。

现在我们把一个对象想像成一棵树：  
对象A有B,C,D三个子对象，其中子对象D中有个属性E引用了对象A下面的子对象B。

![](https://pic1.zhimg.com/80/v2-e0215f84e6ffffe310af4bbf28ba29f8_720w.png)

用代码来表示就是这样：

```javascript
var A = {
    B: {
        name: 'b'
    },
    C: {
        name: 'c'
    },
    D: {

    }
};
A.D.E = A.B;
```

此时 A.D.E 与 A.B 是相等的，因为他们引用了同一个对象：

```javascript
console.log(A.B === A.D.E) // 输出： true
```

如果再调用刚才的DeepCopy函数深拷贝一份对象A的副本X：

```javascript
var X = DeepCopy(A);
console.log(X.B); // 输出： {name: "b"}
console.log(X.D.E);// 输出: {name: "b"}
console.log(X.B === X.D.E); // 输出： false
```

虽然 X.B 和 X.D.E在字面意义上是相等的，但二者并不是引用的同一个对象，这点上来看对象 X和对象A还是有差异的。

这种情况是因为 A.B 并不在 A.D.E 的父级对象链上，所以deepCopy函数就无法检测到A.D.E对A.B也是一种引用关系，所以deepCopy函数就将A.B深拷贝的结果赋值给了 X.D.E。

知道原因那么解决方案就呼之欲出了：父级的引用是一种引用，非父级的引用也是一种引用，那么只要记录下对象A中的所有对象，并与新创建的对象一一对应即可。

```javascript
function eepCopy(obj) {
    // Hash表 记录所有的对象引用关系
    let map = new WeakMap();
    function dp(obj) {
        let result = null;
        let keys = null,
            key = null,
            temp = null,
            existObj = null;
        
        existObj = map.get(obj);
        // 如果这个对象已被记录则直接返回
        if (existObj) {
            return existObj;
        }
        keys = Object.keys(obj);
        result = {};
        // 记录当前对象
        map.set(obj,result);
        for (let i = 0; i < keys.length; i++) {
            key = keys[i];
            temp = obj[key];
            // 如果字段的值也是一个对象则递归复制
            if (temp && typeof temp === 'object') {
                result[key] = dp(temp);
            } else {
                // 否则直接赋值给新对象
                result[key] = temp;
            }
        }
        return result;
    }
    return dp(obj);
}
```

测试一下看看：

```javascript
var X = deepCopy(A);
console.log(X.B); // >> {name: "b"}
console.log(X.D.E);// >> {name: "b"}
console.log(X.B === X.D.E); // >> true
```



