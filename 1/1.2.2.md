# 壹.2.2 作用域、执行上下文、作用域链

JavaScript不同于其他大多数高级语言，比如Java语言有**块级作用域**，也就是由一个花括号对`{……}`的位置决定作用域，而在 ES6 之前，Javascript却不是这样的，它使用**函数作用域**和**全局作用域**，直到ES6出现之后，才有了**块级作用域**。

很多前端工程师写了3年的代码，其实并不一定能讲清楚什么是**作用域**、什么是**作用域链**，尤其对**执行上下文**的概念不太清楚。

如果对这3个基础概念不清晰，后面使用JavaScript做项目，就会失之毫厘，谬以千里。做得越多越糊涂，往往停留在只会写，或者调试了很多次积累了一些经验，但是不懂原因无法触类旁通，碰到一点变化就无法快速应对。

## 壹.2.2.1 作用域（Scope）

**作用域即函数或变量的可见区域**。通俗点说，函数或者变量不在这个区域内，就无法访问到。

### 函数作用域

用函数形式以`function(){……}`类似的代码包起来的（省略号`……`）区域，即**函数作用域**。

与函数作用域相对应的概念是**全局作用域**，也就是定义在最外层的变量或者函数，可以在任何地方访问到它们。前端工程师们在入门阶段应该已经学习并熟悉过这个概念，故不再举例赘述，后面我们重点研究函数作用域。

```javascript
var a = "coffe";//在全局作用域
function func(){
    var b="coffe";//在函数作用域内
    console.log(a);
}

console.log(a);//>> coffe
console.log(b);//>> Uncaught ReferenceError: b is not defined
func();//>> coffe
```

如上，`a`定义在全局作用域内，任何地方都可见，所以函数`func`内能访问到`a`；而`b`定义在函数`func`内，可见区域就是函数代码块，后面的打印命令`console.log(b)`在函数`func`之外执行的，访问不到函数`func`内的`b`，因此输出`Uncaught ReferenceError: b is not defined`。

任意代码片段外面用函数包装起来，就好像加了一层防护罩似的，可以将内部的变量和函数隐蔽起来，外部无法访问到内部的内容。

上面这个例子，展示一种办法：可用函数将一些东西隐藏起来。这种办法在日常开发中很有用！

```javascript
//全局作用域

function func(){//作用域A
    var a = "coffe";
    
    function func1(){//作用域B。定义一个函数，把不想公开的内容隐藏起来
        var a = "1891";//这里的a把外层的a的值覆盖了
        var b = "b";
        
        //这里可以放有很多其他要对外隐藏的内容：变量或者函数
        //……
        //…
        
        console.log(a);
    }
    
    console.log(a);//>> coffe
    console.log(b);//>> Uncaught ReferenceError: b is not defined
    func1();//>> 1891
}
```

上面示例了一个嵌套函数，等于有外层函数`func`的作用域A内嵌了函数`func1`的作用域B。在`func1`里面的打印命令`console.log(a)`访问变量`a`时，JS引擎会**先从离自己最近的作用域**A查找变量`a`，找到就不再继续查找，找不到就去上层作用域（此例中上层作用域是全局作用域）继续查找，此例中`a`已经找到且值为`"coffe"`，所以打印输出`coffe`。依此类推，执行`func1()`，会执行`func1`函数内部的`console.log(a)`，随即会在作用域B查找里面`a`，而作用B里面存在一个`a`的声明和赋值语句`var a = "1891"`，所以最先找到`a`的值是`1891`，找到便不再继续查找，最终`func1()`输出`1891`而不是`coffe`。

但是每次都要定义一个“不重名的函数名“放在上一级作用域里，显得有点浪费内存空间，而且要想不重复的名字有点头疼。所以最好还是匿名函数的形式包起来，然后立即执行，也即IIFE。如下示例：

```javascript
//全局作用域

function func(){//作用域A
    var a = "coffe";
    
    (function(){//作用域B。一个IIFE形式的函数，把不想公开的内容隐藏起来
        var a = "1891";
        var b = "b";
        
        //这里可以放有很多其他要对外隐藏的内容：变量或者函数
        //……
        //…
        
        console.log(a);
    })();//>> 1891
    
    console.log(a);//>> coffe
    console.log(b);//>> Uncaught ReferenceError: b is not defined
}
```

如上，用一个IIFE加匿名函数的写法，把变量`b`隐藏起来，函数外面就没法访问它，函数内部可以访问到它。本书推荐你在任何时候都尽量用匿名函数把要调试的代码片段包起来，然后用IIFE的形式立即执行，而且本书后面也会遵守这个约定。

### 让我们用图来解释

上面那块代码，有几个作用域呢？画图来说明会更加容易理解。

![](../.gitbook/assets/image%20%2824%29.png)

如图所示，有3个作用域，从最外层往内分别是全局作用域、func、IIFE。

### ES6带来了块级作用域

ES6规定，在某个花括号对`{ }`的内部**用`let`关键字生声明的变量和函数拥有块级作用域**，这些变量和函数它们只能被花括号对`{ }`的内部的语句使用，外部不可访问。在你写下代码的时候，变量和函数的块级作用域就已经确定下来。**块级作用域和函数作用域也可以统称为局部作用域**。 

ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，在块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。但是这样的处理规则显然会对老代码产生很大的影响，出于向后（backward）兼容的考虑，在块级作用域中声明的函数依然可以在作用域外部引用。如果需要函数只在块级作用域中起作用，应该用let关键字写成函数表达式，而不是函数声明语句。为了证明该段论述，我们来看一段代码。

```javascript
{
  function func(){//函数声明
    return 1;
  }
}
console.log(func());//>> 1
```

上面这段代码，函数`func`明明是在花括号内部声明的，按 ES6 原本的规范，外部应该是不可访问的，但实际上可以，证明JS引擎为了向后兼容在实现ES6规范的时候做了变通处理。再来看一段代码。

```javascript
{
  var func = function (){//未使用let关键字的函数表达式
    return 1;
  }
}
console.log(func());//>> 1
```

上面这段代码与它之前那一段代码效果是一样。

```javascript
{
  let func = function (){
    return 1;
  }
}
console.log(func());//>> func is not defined
```

上面这段代码证明，在花括号`{}`内部由`let`关键字声明的函数，才是真正的处于块级作用域内部。

### 为什么要引进块级作用域？

有了全局作用域和函数作用域，以及`var`已经挺好用的了，为何还要引进块级作用域和关键字`let`呢？

首先，的确，ES6 之前函数作用域和`var`结合也很好用，但是终究没有`{}`和`let`结合来的块级作用域来的简洁！

其次，var声明的变量有副作用：**声明提前**。

```javascript
(function() {
  console.log(a); //>> undefined
  console.log(b); //>> ReferenceError
  var a = "coffe"; //声明提前
  let b = "1891"; //由let关键字声明的变量，不存在提前的特性
})();
```

上面这段代码，其中`var a = "coffe"` 含两个操作，一个是变量`a`的**声明**（也即`var a`\)，一个是赋值（也即`a = "coffe"`）。声明提前的意思是，用var关键字声明的变量，其实可以看做是在函数体内最顶端声明的，所以`console.log(a)`输出undefined，代表该变量已经被声明过（但还未赋值）。声明提前这个特性，让很多程序员容易变得十分迷惑。按理说，变量（或函数）应是在声明之后才能读取（查找）的，但是`var`已经让这个常理变得近似诡异，let的出现能让这诡异回归常理。

再次，因为`var`声明变量有污染。

```javascript
(function() {
  for (var i = 0; i < 100; i++) {
    //……很多行代码
  }
  function func() {
    //……很多行代码
  }
  //……很多行代码
  console.log(i); //>> 100
})();
```

循环里面的i在循环完毕后就没有用了，但并没有被回收掉，而是一直存在的“垃圾”变量，污染了当前的环境。而用`let`声明变量，事后这种垃圾变量会很快被回收掉。

```javascript
(function() {
  for (let i = 0; i < 100; i++) {
    //……很多行代码
  }
  function func() {
    //……很多行代码
  }
  //……很多行代码
  console.log(i); //>> ReferenceError
})();
```

综上，你应该使用**let**，尽量的避免使用**var**，当然你想定义一个全局变量除外。

## 壹.2.2.2 执行上下文（Execution Context）

### 定义

执行上下文就是当前 JavaScript 代码被解析和执行时所在的环境，也叫作执行环境。

它是一个抽象概念，意味着我们在脑海中理解一下就好，方便后续
